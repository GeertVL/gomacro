// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package parser implements a parser for Go source files. Input may be
// provided in a variety of forms (see the various Parse* functions); the
// output is an abstract syntax tree (AST) representing the Go source. The
// parser is invoked through one of the Parse* functions.
//
// The parser accepts a larger language than is syntactically permitted by
// the Go spec, for simplicity, and for improved robustness in the presence
// of syntax errors. For instance, in method declarations, the receiver is
// treated like an ordinary parameter list and thus may contain multiple
// entries where the spec permits exactly one. Consequently, the corresponding
// field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.
//
package parser

import (
	"fmt"
	"go/ast"
	"go/token"

	mt "github.com/cosmos72/gomacro/token"
)

func (p *Parser) parseAny() ast.Node {
	var node ast.Node

	if p.tok == token.COMMENT {
		// advance to the next non-comment token
		p.next()
	}
	switch p.tok {
	case token.PACKAGE:
		node = p.parseFile()
	case token.IMPORT:
		node = p.parseGenDecl(token.IMPORT, p.parseImportSpec)
	case token.CONST, token.FUNC, token.TYPE, token.VAR, mt.MACRO:
		node = p.parseDecl(syncDecl)
	default:
		node = p.parseStmt(true)
		if expr, ok := node.(*ast.ExprStmt); ok {
			// unwrap expressions
			node = expr.X
		}
	}
	return node
}

// patch: quote and friends
func (p *Parser) parseQuote() ast.Expr {
	if p.trace {
		defer un(trace(p, "Quote"))
	}

	saveDepth := p.quasiquoteDepth
	saveQuote := p.quoteOrMacro

	switch p.tok {
	case mt.QUOTE:
		p.quoteOrMacro = true
	case mt.QUASIQUOTE:
		p.quasiquoteDepth++
	case mt.UNQUOTE, mt.UNQUOTE_SPLICE:
		p.quasiquoteDepth--
	}
	defer func() {
		p.quasiquoteDepth = saveDepth
		p.quoteOrMacro = saveQuote
	}()

	op := p.tok
	opPos := p.pos
	opName := mt.String(op) // use the actual name QUOTE/QUASIQUOTE/UNQUOTE/UNQUOTE_SPLICE even if we found ~' ~` ~, ~,@
	p.next()

	var node ast.Node

	// QUOTE, QUASIQUOTE, UNQUOTE and UNQUOTE_SLICE must be followed by one of:
	// * a basic literal
	// * an identifier
	// * a block statement - containing relaxed syntax, see parseQuotedBlockStmt()
	// * another QUOTE, QUASIQUOTE or UNQUOTE (not UNQUOTE_SPLICE, it must be wrapped in {})
	switch p.tok {
	case token.EOF, token.RPAREN, token.RBRACK, token.RBRACE,
		token.COMMA, token.PERIOD, token.SEMICOLON, token.COLON:

		// no applicable expression after QUOTE/QUASIQUOTE/...: just return the keyword itself
		return &ast.Ident{NamePos: opPos, Name: opName}

	case token.IDENT:
		node = &ast.Ident{NamePos: p.pos, Name: p.lit}
		p.next()

	case token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING:
		node = &ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}
		p.next()

	case mt.QUOTE, mt.QUASIQUOTE, mt.UNQUOTE, mt.UNQUOTE_SPLICE:
		node = p.parseQuote()

	case token.LBRACE:
		// FIXME ideally, we do NOT want to parse macros when inside some depth of QUOTE and QUASIQUOTE
		// because we may not know about the macro yet, and because the macro could be inside fragments like
		//   quasiquote{some_macro unquote_splice{...}}
		// which means there is no way know how many arguments are present,
		// because they will be generated by splicing the results of user code.
		//
		// also, we should allow things like
		//   quasiquote{for unquote_splice{...}}
		// i.e. even the number of arguments to reserved keywords could vary depending on user code
		node = p.parseBlockStmt()

	default:
		p.errorExpected(p.pos, "one of: '{', 'IDENT', 'INT', 'STRING', 'QUOTE', 'QUASIQUOTE', 'UNQUOTE' or 'UNQUOTE_SPLICE'")
	}

	expr, _ := p.MakeQuote(op, opPos, node)
	return expr
}

// MakeQuote creates an ast.UnaryExpr representing quote{node}.
// Returns both the unaryexpr and the blockstmt containing its body
func (p *Parser) MakeQuote(op token.Token, pos token.Pos, node ast.Node) (*ast.UnaryExpr, *ast.BlockStmt) {
	var body *ast.BlockStmt
	var stmt ast.Stmt
	switch node := node.(type) {
	case nil:
		break
	case *ast.BlockStmt:
		body = node
	case ast.Stmt:
		stmt = node
	case ast.Expr:
		stmt = &ast.ExprStmt{X: node}
	default:
		msg := fmt.Sprintf("%v: expecting statement or expression, found %T %#v", op, node)
		if p != nil {
			p.error(node.Pos(), msg)
		} else {
			panic(msg)
		}
	}
	if body == nil {
		list := make([]ast.Stmt, 0)
		if stmt != nil {
			list = append(list, stmt)
		}
		body = &ast.BlockStmt{Lbrace: stmt.Pos(), List: list, Rbrace: stmt.End()}
	}

	// due to go/ast strictly typed model, there is only one mechanism
	// to insert a statement inside an expression: use a closure.
	// so we return a unary expression: QUOTE (func() { /*block*/ })
	typ := &ast.FuncType{Func: token.NoPos, Params: &ast.FieldList{}}
	fun := &ast.FuncLit{Type: typ, Body: body}
	return &ast.UnaryExpr{OpPos: pos, Op: op, X: fun}, body
}

// macro calls syntax is "foo bar [;] baz"... recognize and report it even if "foo" is not defined
func (p *Parser) expectSemiOrMacro() (maybeMacro bool) {
	// semicolon is optional before a closing ')' or '}'
	switch p.tok {
	case token.RPAREN, token.RBRACK, token.RBRACE:
		break
	case token.COMMA:
		// permit a ',' instead of a ';' but complain
		p.errorExpected(p.pos, "';'")
		fallthrough
	case token.SEMICOLON:
		p.next()
	default:
		return true
	}
	return false
}

func isMacroDecl(decl *ast.FuncDecl) bool {
	return decl != nil && decl.Recv != nil && decl.Recv.List != nil && len(decl.Recv.List) == 0
}

func funcDeclNumParams(decl *ast.FuncDecl) int {
	return decl.Type.Params.NumFields()
}

func (p *Parser) tryParseMacroStmt() ast.Stmt {
	if expr := p.tryParseMacroExpr(); expr != nil {
		return &ast.ExprStmt{X: expr}
	}
	return nil
}

// if current token is an identifier currently defined as a macro,
// retrieve the number of arguments it expects and parse it accordingly
func (p *Parser) tryParseMacroExpr() ast.Expr {
	if p.quasiquoteDepth > 0 || p.quoteOrMacro {
		return nil
	}
	pos := p.pos
	if p.tok != token.IDENT {
		p.errorExpected(pos, "'"+token.IDENT.String()+"'")
		return nil
	}
	name := p.lit
	ident := &ast.Ident{NamePos: pos, Name: name}

	p.tryResolve(ident, false)
	if ident.Obj == nil || ident.Obj.Decl == nil {
		return nil
	}
	switch decl := ident.Obj.Decl.(type) {
	case *ast.FuncDecl:
		if isMacroDecl(decl) {
			n := funcDeclNumParams(decl)
			return p.parseMacro(ident, n)
		}
	}
	return nil
}

// parseMacro parses a macro accepting numParams parameters
// or until RPAREN, RBRACK or RBRACE if numParams < 0
func (p *Parser) parseMacro(node ast.Node, numParams int) ast.Expr {
	if p.trace {
		defer un(trace(p, "Macro"))
	}
	assert(numParams < 0 || !p.quoteOrMacro, "parseMacro invoked with p.quoteOrMacro == true and numParams >= 0")
	if !p.quoteOrMacro {
		p.quoteOrMacro = true
		defer func() {
			p.quoteOrMacro = false
		}()
	}

	if numParams >= 0 {
		p.expect(token.IDENT)
	} else if p.trace {
		p.printTrace("<stealing last node>", node)
	}
	// we could try to execute the macro here - but there are two issues:
	//
	// the first is stylistic: this is a parser, not an interpreter.
	//
	// the second is technical: a recursive-descent parser like this
	// builds the AST built bottom-up: first creates the leaves,
	// then the internal nodes pointing to the leaves, and continues up to the root.
	// On the other hand, macroexpansion with lisp-like semantics is top-down:
	// it starts with the *whole* AST tree, and recursively descends it
	// expanding macros on the way. Trying to mix the two approaches
	// is likely to introduce *exponential* slowdowns due to the same AST fragments
	// being macroexpanded again and again while the parser builds AST nodes
	// progressively farther away from the leaves.
	//
	// TL;DR: performing macroexpansion here is a mess. Let the interpreter do it.

	var first ast.Expr
	switch node := node.(type) {
	case ast.Expr:
		first = node
	case *ast.ExprStmt:
		first = node.X
	default:
		// the macro name is itself a statement? then wrap in a unary expression MACRO func() { /*...*/ }
		// as we do for QUOTE and friends
		first, _ = p.MakeQuote(mt.MACRO, node.Pos(), node)
	}

	var list []ast.Stmt
	lbrace := p.pos
	if numParams >= 0 {
		// number of parameters is known
		list = make([]ast.Stmt, numParams)
		for i := 0; i < numParams; i++ {
			list[i] = p.parseStmt(true) // rely on parseStmt() error and EOF detection
			if p.Mode&TraceMacro != 0 {
				p.printTrace("<macro with", numParams, "arguments> parsed", list[len(list)-1])
			}
		}
	} else {
		// number of parameters is unknown, continue until EOF, RPAREN, RBRACK or RBRACE
		for p.tok != token.EOF && p.tok != token.RPAREN && p.tok != token.RBRACK && p.tok != token.RBRACE {
			list = append(list, p.parseStmt(true))
			if p.Mode&TraceMacro != 0 {
				p.printTrace("<macro with unknown arguments> parsed", list[len(list)-1])
			}
		}
	}
	rbrace := p.pos

	body := &ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}

	// due to go/ast strictly typed model, there is only one mechanism
	// to insert a statement inside an expression: use a closure.
	// so we return a binary expression: ident MACRO (func() { /*block*/ })
	typ := &ast.FuncType{Func: token.NoPos, Params: &ast.FieldList{}}
	fun := &ast.FuncLit{Type: typ, Body: body}
	return &ast.BinaryExpr{X: first, OpPos: first.Pos(), Op: mt.MACRO, Y: fun}
}
