--- /usr/local/go/src/go/parser/parser.go	2017-02-16 19:27:47.000000000 +0000
+++ parser.go	2017-04-02 13:54:30.000000000 +0000
@@ -19,11 +19,13 @@
 import (
 	"fmt"
 	"go/ast"
-	"go/scanner"
 	"go/token"
 	"strconv"
 	"strings"
 	"unicode"
+
+	"github.com/cosmos72/gomacro/scanner"
+	mt "github.com/cosmos72/gomacro/token"
 )
 
 // The parser structure holds the parser's internal state.
@@ -33,15 +35,21 @@
 	scanner scanner.Scanner
 
 	// Tracing/debugging
-	mode   Mode // parsing mode
+	Mode   Mode // parsing mode
 	trace  bool // == (mode & Trace != 0)
 	indent int  // indentation used for tracing output
 
+	SpecialChar rune // patch: prefix for quote operators ' ` , ,@
+	Fileset     *token.FileSet
+
 	// Comments
 	comments    []*ast.CommentGroup
 	leadComment *ast.CommentGroup // last lead comment
 	lineComment *ast.CommentGroup // last line comment
 
+	// Previous token
+	tok0 token.Token
+
 	// Next token
 	pos token.Pos   // token position
 	tok token.Token // one token look-ahead
@@ -70,17 +78,52 @@
 	targetStack [][]*ast.Ident // stack of unresolved labels
 }
 
-func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mode) {
-	p.file = fset.AddFile(filename, -1, len(src))
+func (p *parser) Init(filename string, src []byte) {
+
+	// Explicitly initialize all private fields since a parser may be reused.
+	if p.Fileset == nil {
+		p.Fileset = token.NewFileSet()
+	}
+	p.file = p.Fileset.AddFile(filename, -1, len(src))
+	p.errors = nil
+
+	mode := p.Mode
 	var m scanner.Mode
 	if mode&ParseComments != 0 {
 		m = scanner.ScanComments
 	}
+	if p.SpecialChar == '\x00' {
+		p.SpecialChar = '~'
+	}
 	eh := func(pos token.Position, msg string) { p.errors.Add(pos, msg) }
-	p.scanner.Init(p.file, src, eh, m)
+	p.scanner.Init(p.file, src, eh, m, p.SpecialChar)
 
-	p.mode = mode
 	p.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)
+	p.indent = 0
+
+	p.comments = nil
+	p.leadComment = nil
+	p.lineComment = nil
+
+	p.pos = token.NoPos
+	p.tok = token.ILLEGAL
+	p.lit = ""
+
+	p.syncPos = token.NoPos
+	p.syncCnt = 0
+
+	p.exprLev = 0
+	p.inRhs = false
+
+	p.topScope = nil
+	p.openScope()
+	p.pkgScope = p.topScope
+
+	p.unresolved = nil
+	p.imports = nil
+
+	p.labelScope = nil
+	p.targetStack = nil
 
 	p.next()
 }
@@ -107,7 +150,7 @@
 	scope := p.labelScope
 	for _, ident := range p.targetStack[n] {
 		ident.Obj = scope.Lookup(ident.Name)
-		if ident.Obj == nil && p.mode&DeclarationErrors != 0 {
+		if ident.Obj == nil && p.Mode&DeclarationErrors != 0 {
 			p.error(ident.Pos(), fmt.Sprintf("label %s undefined", ident.Name))
 		}
 	}
@@ -126,7 +169,7 @@
 		obj.Data = data
 		ident.Obj = obj
 		if ident.Name != "_" {
-			if alt := scope.Insert(obj); alt != nil && p.mode&DeclarationErrors != 0 {
+			if alt := scope.Insert(obj); alt != nil && p.Mode&DeclarationErrors != 0 {
 				prevDecl := ""
 				if pos := alt.Pos(); pos.IsValid() {
 					prevDecl = fmt.Sprintf("\n\tprevious declaration at %s", p.file.Position(pos))
@@ -160,7 +203,7 @@
 			p.errorExpected(x.Pos(), "identifier on left side of :=")
 		}
 	}
-	if n == 0 && p.mode&DeclarationErrors != 0 {
+	if n == 0 && p.Mode&DeclarationErrors != 0 {
 		p.error(list[0].Pos(), "no new variables on left side of :=")
 	}
 }
@@ -243,11 +286,13 @@
 	// very first token (!p.pos.IsValid()) is not initialized
 	// (it is token.ILLEGAL), so don't print it .
 	if p.trace && p.pos.IsValid() {
-		s := p.tok.String()
+		s := mt.String(p.tok) // patch: support macro-related keywords
 		switch {
 		case p.tok.IsLiteral():
 			p.printTrace(s, p.lit)
-		case p.tok.IsOperator(), p.tok.IsKeyword():
+		case p.tok.IsOperator(), p.tok.IsKeyword(),
+			mt.IsMacroKeyword(p.tok): // patch: support macro-related keywords
+
 			p.printTrace("\"" + s + "\"")
 		default:
 			p.printTrace(s)
@@ -274,7 +319,7 @@
 	comment = &ast.Comment{Slash: p.pos, Text: p.lit}
 	p.next0()
 
-	return
+	return comment, endline
 }
 
 // Consume a group of adjacent comments, add it to the parser's
@@ -317,6 +362,7 @@
 	p.leadComment = nil
 	p.lineComment = nil
 	prev := p.pos
+	p.tok0 = p.tok
 	p.next0()
 
 	if p.tok == token.COMMENT {
@@ -349,7 +395,7 @@
 }
 
 // A bailout panic is raised to indicate early termination.
-type bailout struct{}
+type Bailout struct{}
 
 func (p *parser) error(pos token.Pos, msg string) {
 	epos := p.file.Position(pos)
@@ -357,13 +403,13 @@
 	// If AllErrors is not set, discard errors reported on the same line
 	// as the last recorded error and stop parsing if there are more than
 	// 10 errors.
-	if p.mode&AllErrors == 0 {
+	if p.Mode&AllErrors == 0 {
 		n := len(p.errors)
 		if n > 0 && p.errors[n-1].Pos.Line == epos.Line {
 			return // discard - likely a spurious error
 		}
 		if n > 10 {
-			panic(bailout{})
+			panic(Bailout{})
 		}
 	}
 
@@ -378,7 +424,7 @@
 		if p.tok == token.SEMICOLON && p.lit == "\n" {
 			msg += ", found newline"
 		} else {
-			msg += ", found '" + p.tok.String() + "'"
+			msg += ", found '" + mt.String(p.tok) + "'"
 			if p.tok.IsLiteral() {
 				msg += " " + p.lit
 			}
@@ -390,7 +436,7 @@
 func (p *parser) expect(tok token.Token) token.Pos {
 	pos := p.pos
 	if p.tok != tok {
-		p.errorExpected(pos, "'"+tok.String()+"'")
+		p.errorExpected(pos, "'"+mt.String(tok)+"'")
 	}
 	p.next() // make progress
 	return pos
@@ -1154,6 +1200,16 @@
 
 	case token.FUNC:
 		return p.parseFuncTypeOrLit()
+
+	// patch: quote and friends
+	// TODO: accept ms.MACRO here and interpret as local macro definition? (i.e. Common Lisp macrolet)
+	case mt.QUOTE, mt.QUASIQUOTE, mt.UNQUOTE, mt.UNQUOTE_SPLICE:
+		return p.parseQuote()
+
+	// patch: accept block statements inside expressions. allows to nest macro calls,
+	// to write { if a { b } else { c } } inside an expression, and many other things
+	case token.LBRACE:
+		return p.parseExprBlock()
 	}
 
 	if typ := p.tryIdentOrType(); typ != nil {
@@ -1432,10 +1488,13 @@
 
 // If x is of the form (T), unparen returns unparen(T), otherwise it returns x.
 func unparen(x ast.Expr) ast.Expr {
-	if p, isParen := x.(*ast.ParenExpr); isParen {
-		x = unparen(p.X)
+	for {
+		if p, ok := x.(*ast.ParenExpr); ok {
+			x = p.X
+			continue
+		}
+		return x
 	}
-	return x
 }
 
 // checkExprOrType checks that x is an expression or a type
@@ -1701,6 +1760,10 @@
 			// Go spec: The scope of a label is the body of the function
 			// in which it is declared and excludes the body of any nested
 			// function.
+			if p.labelScope == nil {
+				p.error(label.Pos(), fmt.Sprintf("syntax error: label outside block: %s", label.Name))
+				return p.parseStmt(), false
+			}
 			stmt := &ast.LabeledStmt{Label: label, Colon: colon, Stmt: p.parseStmt()}
 			p.declare(stmt, nil, p.labelScope, ast.Lbl, label)
 			return stmt, false
@@ -2165,13 +2228,15 @@
 		// tokens that may start an expression
 		token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operands
 		token.LBRACK, token.STRUCT, token.MAP, token.CHAN, token.INTERFACE, // composite types
-		token.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT: // unary operators
+		token.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT, // unary operators
+		mt.MACRO, mt.SPLICE, mt.QUOTE, mt.QUASIQUOTE, mt.UNQUOTE, mt.UNQUOTE_SPLICE: // patch: macro, quote and friends
+
 		s, _ = p.parseSimpleStmt(labelOk)
 		// because of the required look-ahead, labeled statements are
 		// parsed by parseSimpleStmt - don't expect a semicolon after
 		// them
 		if _, isLabeledStmt := s.(*ast.LabeledStmt); !isLabeledStmt {
-			p.expectSemi()
+			p.expectSemiOrSpace()
 		}
 	case token.GO:
 		s = p.parseGoStmt()
@@ -2202,7 +2267,6 @@
 		// a semicolon may be omitted before a closing "}"
 		s = &ast.EmptyStmt{Semicolon: p.pos, Implicit: true}
 	default:
-		// no statement found
 		pos := p.pos
 		p.errorExpected(pos, "statement")
 		syncStmt(p)
@@ -2370,13 +2434,37 @@
 	if p.trace {
 		defer un(trace(p, "FunctionDecl"))
 	}
+	decl := p.parseFuncOrMacroDecl(token.FUNC)
+
+	// paranoia: empty receiver list is omitted. this should not happen,
+	// but we use it to distinguish functions from macros, so better safe than sorry.
+	recv := decl.Recv
+	if recv != nil && len(recv.List) == 0 {
+		decl.Recv = nil
+	}
+	return decl
+}
+
+// patch: parse a macro declaration
+func (p *parser) parseMacroDecl() *ast.FuncDecl {
+	if p.trace {
+		defer un(trace(p, "MacroDecl"))
+	}
+	decl := p.parseFuncOrMacroDecl(mt.MACRO)
+	// add zero-length receiver list, to mark decl as a macro
+	decl.Recv = &ast.FieldList{List: []*ast.Field{}}
+	return decl
+}
+
+func (p *parser) parseFuncOrMacroDecl(tok token.Token) *ast.FuncDecl {
 
 	doc := p.leadComment
-	pos := p.expect(token.FUNC)
+	pos := p.expect(tok)
 	scope := ast.NewScope(p.topScope) // function scope
 
 	var recv *ast.FieldList
-	if p.tok == token.LPAREN {
+	// patch: macros cannot have a receiver
+	if tok == token.FUNC && p.tok == token.LPAREN {
 		recv = p.parseParameters(scope, false)
 	}
 
@@ -2432,6 +2520,9 @@
 	case token.FUNC:
 		return p.parseFuncDecl()
 
+	case mt.MACRO: // patch: parse a macro declaration
+		return p.parseMacroDecl()
+
 	default:
 		pos := p.pos
 		p.errorExpected(pos, "declaration")
@@ -2462,7 +2553,7 @@
 	// Go spec: The package clause is not a declaration;
 	// the package name does not appear in any scope.
 	ident := p.parseIdent()
-	if ident.Name == "_" && p.mode&DeclarationErrors != 0 {
+	if ident.Name == "_" && p.Mode&DeclarationErrors != 0 {
 		p.error(p.pos, "invalid package name _")
 	}
 	p.expectSemi()
@@ -2473,25 +2564,30 @@
 		return nil
 	}
 
-	p.openScope()
-	p.pkgScope = p.topScope
+	topScope := p.topScope
+	labelScope := p.labelScope
+	if topScope == nil {
+		p.openScope()
+	}
 	var decls []ast.Decl
-	if p.mode&PackageClauseOnly == 0 {
+	if p.Mode&PackageClauseOnly == 0 {
 		// import decls
 		for p.tok == token.IMPORT {
 			decls = append(decls, p.parseGenDecl(token.IMPORT, p.parseImportSpec))
 		}
 
-		if p.mode&ImportsOnly == 0 {
+		if p.Mode&ImportsOnly == 0 {
 			// rest of package body
 			for p.tok != token.EOF {
 				decls = append(decls, p.parseDecl(syncDecl))
 			}
 		}
 	}
-	p.closeScope()
-	assert(p.topScope == nil, "unbalanced scopes")
-	assert(p.labelScope == nil, "unbalanced label scopes")
+	if topScope == nil {
+		p.closeScope()
+	}
+	assert(p.topScope == topScope, "unbalanced scopes")
+	assert(p.labelScope == labelScope, "unbalanced label scopes")
 
 	// resolve global identifiers within the same file
 	i := 0
