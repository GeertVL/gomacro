--- /usr/local/go/src/go/parser/parser.go	2017-02-16 20:27:47.000000000 +0100
+++ parser.go	2017-02-24 21:46:07.009279263 +0100
@@ -14,20 +14,22 @@
 // entries where the spec permits exactly one. Consequently, the corresponding
 // field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.
 //
-package parser
+package macroparser
 
 import (
 	"fmt"
 	"go/ast"
-	"go/scanner"
 	"go/token"
 	"strconv"
 	"strings"
 	"unicode"
+
+	"github.com/cosmos72/gomacro/scanner"
+	mt "github.com/cosmos72/gomacro/token"
 )
 
 // The parser structure holds the parser's internal state.
-type parser struct {
+type Parser struct {
 	file    *token.File
 	errors  scanner.ErrorList
 	scanner scanner.Scanner
@@ -70,8 +72,11 @@
 	targetStack [][]*ast.Ident // stack of unresolved labels
 }
 
-func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mode) {
+func (p *Parser) Init(fset *token.FileSet, filename string, src []byte, mode Mode, scope *ast.Scope) *ast.Scope {
+	// Explicitly initialize all fields since a parser may be reused.
 	p.file = fset.AddFile(filename, -1, len(src))
+	p.errors = nil
+
 	var m scanner.Mode
 	if mode&ParseComments != 0 {
 		m = scanner.ScanComments
@@ -81,27 +86,56 @@
 
 	p.mode = mode
 	p.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)
+	p.indent = 0
+
+	p.comments = nil
+	p.leadComment = nil
+	p.lineComment = nil
+
+	p.pos = token.NoPos
+	p.tok = token.ILLEGAL
+	p.lit = ""
+
+	p.syncPos = token.NoPos
+	p.syncCnt = 0
+
+	p.exprLev = 0
+	p.inRhs = false
+
+	p.topScope = scope
+	if scope == nil {
+		p.openScope()
+	}
+	p.pkgScope = p.topScope
+
+	p.unresolved = nil
+	p.imports = nil
+
+	p.labelScope = nil
+	p.targetStack = nil
 
 	p.next()
+
+	return p.topScope
 }
 
 // ----------------------------------------------------------------------------
 // Scoping support
 
-func (p *parser) openScope() {
+func (p *Parser) openScope() {
 	p.topScope = ast.NewScope(p.topScope)
 }
 
-func (p *parser) closeScope() {
+func (p *Parser) closeScope() {
 	p.topScope = p.topScope.Outer
 }
 
-func (p *parser) openLabelScope() {
+func (p *Parser) openLabelScope() {
 	p.labelScope = ast.NewScope(p.labelScope)
 	p.targetStack = append(p.targetStack, nil)
 }
 
-func (p *parser) closeLabelScope() {
+func (p *Parser) closeLabelScope() {
 	// resolve labels
 	n := len(p.targetStack) - 1
 	scope := p.labelScope
@@ -116,7 +150,7 @@
 	p.labelScope = p.labelScope.Outer
 }
 
-func (p *parser) declare(decl, data interface{}, scope *ast.Scope, kind ast.ObjKind, idents ...*ast.Ident) {
+func (p *Parser) declare(decl, data interface{}, scope *ast.Scope, kind ast.ObjKind, idents ...*ast.Ident) {
 	for _, ident := range idents {
 		assert(ident.Obj == nil, "identifier already declared or resolved")
 		obj := ast.NewObj(kind, ident.Name)
@@ -137,7 +171,7 @@
 	}
 }
 
-func (p *parser) shortVarDecl(decl *ast.AssignStmt, list []ast.Expr) {
+func (p *Parser) shortVarDecl(decl *ast.AssignStmt, list []ast.Expr) {
 	// Go spec: A short variable declaration may redeclare variables
 	// provided they were originally declared in the same block with
 	// the same type, and at least one of the non-blank variables is new.
@@ -175,7 +209,7 @@
 // set, x is marked as unresolved and collected in the list of unresolved
 // identifiers.
 //
-func (p *parser) tryResolve(x ast.Expr, collectUnresolved bool) {
+func (p *Parser) tryResolve(x ast.Expr, collectUnresolved bool) {
 	// nothing to do if x is not an identifier or the blank identifier
 	ident, _ := x.(*ast.Ident)
 	if ident == nil {
@@ -202,14 +236,14 @@
 	}
 }
 
-func (p *parser) resolve(x ast.Expr) {
+func (p *Parser) resolve(x ast.Expr) {
 	p.tryResolve(x, true)
 }
 
 // ----------------------------------------------------------------------------
 // Parsing support
 
-func (p *parser) printTrace(a ...interface{}) {
+func (p *Parser) printTrace(a ...interface{}) {
 	const dots = ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
 	const n = len(dots)
 	pos := p.file.Position(p.pos)
@@ -224,30 +258,32 @@
 	fmt.Println(a...)
 }
 
-func trace(p *parser, msg string) *parser {
+func trace(p *Parser, msg string) *Parser {
 	p.printTrace(msg, "(")
 	p.indent++
 	return p
 }
 
 // Usage pattern: defer un(trace(p, "..."))
-func un(p *parser) {
+func un(p *Parser) {
 	p.indent--
 	p.printTrace(")")
 }
 
 // Advance to the next token.
-func (p *parser) next0() {
+func (p *Parser) next0() {
 	// Because of one-token look-ahead, print the previous token
 	// when tracing as it provides a more readable output. The
 	// very first token (!p.pos.IsValid()) is not initialized
 	// (it is token.ILLEGAL), so don't print it .
 	if p.trace && p.pos.IsValid() {
-		s := p.tok.String()
+		s := mt.String(p.tok) // patch: support macro-related keywords
 		switch {
 		case p.tok.IsLiteral():
 			p.printTrace(s, p.lit)
-		case p.tok.IsOperator(), p.tok.IsKeyword():
+		case p.tok.IsOperator(), p.tok.IsKeyword(),
+			mt.IsMacroKeyword(p.tok): // patch: support macro-related keywords
+
 			p.printTrace("\"" + s + "\"")
 		default:
 			p.printTrace(s)
@@ -258,7 +294,7 @@
 }
 
 // Consume a comment and return it and the line on which it ends.
-func (p *parser) consumeComment() (comment *ast.Comment, endline int) {
+func (p *Parser) consumeComment() (comment *ast.Comment, endline int) {
 	// /*-style comments may end on a different line than where they start.
 	// Scan the comment for '\n' chars and adjust endline accordingly.
 	endline = p.file.Line(p.pos)
@@ -282,7 +318,7 @@
 // the last comment in the group ends. A non-comment token or n
 // empty lines terminate a comment group.
 //
-func (p *parser) consumeCommentGroup(n int) (comments *ast.CommentGroup, endline int) {
+func (p *Parser) consumeCommentGroup(n int) (comments *ast.CommentGroup, endline int) {
 	var list []*ast.Comment
 	endline = p.file.Line(p.pos)
 	for p.tok == token.COMMENT && p.file.Line(p.pos) <= endline+n {
@@ -313,13 +349,14 @@
 // Lead and line comments may be considered documentation that is
 // stored in the AST.
 //
-func (p *parser) next() {
+func (p *Parser) next() {
 	p.leadComment = nil
 	p.lineComment = nil
 	prev := p.pos
 	p.next0()
 
-	if p.tok == token.COMMENT {
+	switch p.tok {
+	case token.COMMENT:
 		var comment *ast.CommentGroup
 		var endline int
 
@@ -349,9 +386,9 @@
 }
 
 // A bailout panic is raised to indicate early termination.
-type bailout struct{}
+type Bailout struct{}
 
-func (p *parser) error(pos token.Pos, msg string) {
+func (p *Parser) error(pos token.Pos, msg string) {
 	epos := p.file.Position(pos)
 
 	// If AllErrors is not set, discard errors reported on the same line
@@ -363,14 +400,14 @@
 			return // discard - likely a spurious error
 		}
 		if n > 10 {
-			panic(bailout{})
+			panic(Bailout{})
 		}
 	}
 
 	p.errors.Add(epos, msg)
 }
 
-func (p *parser) errorExpected(pos token.Pos, msg string) {
+func (p *Parser) errorExpected(pos token.Pos, msg string) {
 	msg = "expected " + msg
 	if pos == p.pos {
 		// the error happened at the current position;
@@ -378,7 +415,7 @@
 		if p.tok == token.SEMICOLON && p.lit == "\n" {
 			msg += ", found newline"
 		} else {
-			msg += ", found '" + p.tok.String() + "'"
+			msg += ", found '" + mt.String(p.tok) + "'"
 			if p.tok.IsLiteral() {
 				msg += " " + p.lit
 			}
@@ -387,10 +424,10 @@
 	p.error(pos, msg)
 }
 
-func (p *parser) expect(tok token.Token) token.Pos {
+func (p *Parser) expect(tok token.Token) token.Pos {
 	pos := p.pos
 	if p.tok != tok {
-		p.errorExpected(pos, "'"+tok.String()+"'")
+		p.errorExpected(pos, "'"+mt.String(tok)+"'")
 	}
 	p.next() // make progress
 	return pos
@@ -399,7 +436,7 @@
 // expectClosing is like expect but provides a better error message
 // for the common case of a missing comma before a newline.
 //
-func (p *parser) expectClosing(tok token.Token, context string) token.Pos {
+func (p *Parser) expectClosing(tok token.Token, context string) token.Pos {
 	if p.tok != tok && p.tok == token.SEMICOLON && p.lit == "\n" {
 		p.error(p.pos, "missing ',' before newline in "+context)
 		p.next()
@@ -407,7 +444,7 @@
 	return p.expect(tok)
 }
 
-func (p *parser) expectSemi() {
+func (p *Parser) expectSemi() {
 	// semicolon is optional before a closing ')' or '}'
 	if p.tok != token.RPAREN && p.tok != token.RBRACE {
 		switch p.tok {
@@ -424,7 +461,7 @@
 	}
 }
 
-func (p *parser) atComma(context string, follow token.Token) bool {
+func (p *Parser) atComma(context string, follow token.Token) bool {
 	if p.tok == token.COMMA {
 		return true
 	}
@@ -441,14 +478,14 @@
 
 func assert(cond bool, msg string) {
 	if !cond {
-		panic("go/parser internal error: " + msg)
+		panic("go/Parser internal error: " + msg)
 	}
 }
 
 // syncStmt advances to the next statement.
 // Used for synchronization after an error.
 //
-func syncStmt(p *parser) {
+func syncStmt(p *Parser) {
 	for {
 		switch p.tok {
 		case token.BREAK, token.CONST, token.CONTINUE, token.DEFER,
@@ -486,7 +523,7 @@
 // syncDecl advances to the next declaration.
 // Used for synchronization after an error.
 //
-func syncDecl(p *parser) {
+func syncDecl(p *Parser) {
 	for {
 		switch p.tok {
 		case token.CONST, token.TYPE, token.VAR:
@@ -517,7 +554,7 @@
 // may be past the file's EOF position, which would lead to panics if used
 // later on.
 //
-func (p *parser) safePos(pos token.Pos) (res token.Pos) {
+func (p *Parser) safePos(pos token.Pos) (res token.Pos) {
 	defer func() {
 		if recover() != nil {
 			res = token.Pos(p.file.Base() + p.file.Size()) // EOF position
@@ -530,7 +567,7 @@
 // ----------------------------------------------------------------------------
 // Identifiers
 
-func (p *parser) parseIdent() *ast.Ident {
+func (p *Parser) parseIdent() *ast.Ident {
 	pos := p.pos
 	name := "_"
 	if p.tok == token.IDENT {
@@ -542,7 +579,7 @@
 	return &ast.Ident{NamePos: pos, Name: name}
 }
 
-func (p *parser) parseIdentList() (list []*ast.Ident) {
+func (p *Parser) parseIdentList() (list []*ast.Ident) {
 	if p.trace {
 		defer un(trace(p, "IdentList"))
 	}
@@ -560,7 +597,7 @@
 // Common productions
 
 // If lhs is set, result list elements which are identifiers are not resolved.
-func (p *parser) parseExprList(lhs bool) (list []ast.Expr) {
+func (p *Parser) parseExprList(lhs bool) (list []ast.Expr) {
 	if p.trace {
 		defer un(trace(p, "ExpressionList"))
 	}
@@ -574,7 +611,7 @@
 	return
 }
 
-func (p *parser) parseLhsList() []ast.Expr {
+func (p *Parser) parseLhsList() []ast.Expr {
 	old := p.inRhs
 	p.inRhs = false
 	list := p.parseExprList(true)
@@ -602,7 +639,7 @@
 	return list
 }
 
-func (p *parser) parseRhsList() []ast.Expr {
+func (p *Parser) parseRhsList() []ast.Expr {
 	old := p.inRhs
 	p.inRhs = true
 	list := p.parseExprList(false)
@@ -613,7 +650,7 @@
 // ----------------------------------------------------------------------------
 // Types
 
-func (p *parser) parseType() ast.Expr {
+func (p *Parser) parseType() ast.Expr {
 	if p.trace {
 		defer un(trace(p, "Type"))
 	}
@@ -631,7 +668,7 @@
 }
 
 // If the result is an identifier, it is not resolved.
-func (p *parser) parseTypeName() ast.Expr {
+func (p *Parser) parseTypeName() ast.Expr {
 	if p.trace {
 		defer un(trace(p, "TypeName"))
 	}
@@ -650,7 +687,7 @@
 	return ident
 }
 
-func (p *parser) parseArrayType() ast.Expr {
+func (p *Parser) parseArrayType() ast.Expr {
 	if p.trace {
 		defer un(trace(p, "ArrayType"))
 	}
@@ -672,7 +709,7 @@
 	return &ast.ArrayType{Lbrack: lbrack, Len: len, Elt: elt}
 }
 
-func (p *parser) makeIdentList(list []ast.Expr) []*ast.Ident {
+func (p *Parser) makeIdentList(list []ast.Expr) []*ast.Ident {
 	idents := make([]*ast.Ident, len(list))
 	for i, x := range list {
 		ident, isIdent := x.(*ast.Ident)
@@ -688,7 +725,7 @@
 	return idents
 }
 
-func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {
+func (p *Parser) parseFieldDecl(scope *ast.Scope) *ast.Field {
 	if p.trace {
 		defer un(trace(p, "FieldDecl"))
 	}
@@ -741,7 +778,7 @@
 	return field
 }
 
-func (p *parser) parseStructType() *ast.StructType {
+func (p *Parser) parseStructType() *ast.StructType {
 	if p.trace {
 		defer un(trace(p, "StructType"))
 	}
@@ -768,7 +805,7 @@
 	}
 }
 
-func (p *parser) parsePointerType() *ast.StarExpr {
+func (p *Parser) parsePointerType() *ast.StarExpr {
 	if p.trace {
 		defer un(trace(p, "PointerType"))
 	}
@@ -780,7 +817,7 @@
 }
 
 // If the result is an identifier, it is not resolved.
-func (p *parser) tryVarType(isParam bool) ast.Expr {
+func (p *Parser) tryVarType(isParam bool) ast.Expr {
 	if isParam && p.tok == token.ELLIPSIS {
 		pos := p.pos
 		p.next()
@@ -797,7 +834,7 @@
 }
 
 // If the result is an identifier, it is not resolved.
-func (p *parser) parseVarType(isParam bool) ast.Expr {
+func (p *Parser) parseVarType(isParam bool) ast.Expr {
 	typ := p.tryVarType(isParam)
 	if typ == nil {
 		pos := p.pos
@@ -808,7 +845,7 @@
 	return typ
 }
 
-func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params []*ast.Field) {
+func (p *Parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params []*ast.Field) {
 	if p.trace {
 		defer un(trace(p, "ParameterList"))
 	}
@@ -867,7 +904,7 @@
 	return
 }
 
-func (p *parser) parseParameters(scope *ast.Scope, ellipsisOk bool) *ast.FieldList {
+func (p *Parser) parseParameters(scope *ast.Scope, ellipsisOk bool) *ast.FieldList {
 	if p.trace {
 		defer un(trace(p, "Parameters"))
 	}
@@ -882,7 +919,7 @@
 	return &ast.FieldList{Opening: lparen, List: params, Closing: rparen}
 }
 
-func (p *parser) parseResult(scope *ast.Scope) *ast.FieldList {
+func (p *Parser) parseResult(scope *ast.Scope) *ast.FieldList {
 	if p.trace {
 		defer un(trace(p, "Result"))
 	}
@@ -901,7 +938,7 @@
 	return nil
 }
 
-func (p *parser) parseSignature(scope *ast.Scope) (params, results *ast.FieldList) {
+func (p *Parser) parseSignature(scope *ast.Scope) (params, results *ast.FieldList) {
 	if p.trace {
 		defer un(trace(p, "Signature"))
 	}
@@ -912,7 +949,7 @@
 	return
 }
 
-func (p *parser) parseFuncType() (*ast.FuncType, *ast.Scope) {
+func (p *Parser) parseFuncType() (*ast.FuncType, *ast.Scope) {
 	if p.trace {
 		defer un(trace(p, "FuncType"))
 	}
@@ -924,7 +961,7 @@
 	return &ast.FuncType{Func: pos, Params: params, Results: results}, scope
 }
 
-func (p *parser) parseMethodSpec(scope *ast.Scope) *ast.Field {
+func (p *Parser) parseMethodSpec(scope *ast.Scope) *ast.Field {
 	if p.trace {
 		defer un(trace(p, "MethodSpec"))
 	}
@@ -952,7 +989,7 @@
 	return spec
 }
 
-func (p *parser) parseInterfaceType() *ast.InterfaceType {
+func (p *Parser) parseInterfaceType() *ast.InterfaceType {
 	if p.trace {
 		defer un(trace(p, "InterfaceType"))
 	}
@@ -976,7 +1013,7 @@
 	}
 }
 
-func (p *parser) parseMapType() *ast.MapType {
+func (p *Parser) parseMapType() *ast.MapType {
 	if p.trace {
 		defer un(trace(p, "MapType"))
 	}
@@ -990,7 +1027,7 @@
 	return &ast.MapType{Map: pos, Key: key, Value: value}
 }
 
-func (p *parser) parseChanType() *ast.ChanType {
+func (p *Parser) parseChanType() *ast.ChanType {
 	if p.trace {
 		defer un(trace(p, "ChanType"))
 	}
@@ -1016,7 +1053,7 @@
 }
 
 // If the result is an identifier, it is not resolved.
-func (p *parser) tryIdentOrType() ast.Expr {
+func (p *Parser) tryIdentOrType() ast.Expr {
 	switch p.tok {
 	case token.IDENT:
 		return p.parseTypeName()
@@ -1047,7 +1084,7 @@
 	return nil
 }
 
-func (p *parser) tryType() ast.Expr {
+func (p *Parser) tryType() ast.Expr {
 	typ := p.tryIdentOrType()
 	if typ != nil {
 		p.resolve(typ)
@@ -1058,7 +1095,7 @@
 // ----------------------------------------------------------------------------
 // Blocks
 
-func (p *parser) parseStmtList() (list []ast.Stmt) {
+func (p *Parser) parseStmtList() (list []ast.Stmt) {
 	if p.trace {
 		defer un(trace(p, "StatementList"))
 	}
@@ -1070,7 +1107,7 @@
 	return
 }
 
-func (p *parser) parseBody(scope *ast.Scope) *ast.BlockStmt {
+func (p *Parser) parseBody(scope *ast.Scope) *ast.BlockStmt {
 	if p.trace {
 		defer un(trace(p, "Body"))
 	}
@@ -1086,7 +1123,7 @@
 	return &ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}
 }
 
-func (p *parser) parseBlockStmt() *ast.BlockStmt {
+func (p *Parser) parseBlockStmt() *ast.BlockStmt {
 	if p.trace {
 		defer un(trace(p, "BlockStmt"))
 	}
@@ -1103,7 +1140,7 @@
 // ----------------------------------------------------------------------------
 // Expressions
 
-func (p *parser) parseFuncTypeOrLit() ast.Expr {
+func (p *Parser) parseFuncTypeOrLit() ast.Expr {
 	if p.trace {
 		defer un(trace(p, "FuncTypeOrLit"))
 	}
@@ -1125,7 +1162,7 @@
 // types of the form [...]T. Callers must verify the result.
 // If lhs is set and the result is an identifier, it is not resolved.
 //
-func (p *parser) parseOperand(lhs bool) ast.Expr {
+func (p *Parser) parseOperand(lhs bool) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "Operand"))
 	}
@@ -1154,6 +1191,11 @@
 
 	case token.FUNC:
 		return p.parseFuncTypeOrLit()
+
+	// patch: quote and friends
+	// TODO: accept ms.MACRO here and interpret as local macro definition? (i.e. Common Lisp macrolet)
+	case mt.QUOTE, mt.QUASIQUOTE, mt.UNQUOTE, mt.UNQUOTE_SPLICE:
+		return p.parseQuote()
 	}
 
 	if typ := p.tryIdentOrType(); typ != nil {
@@ -1170,7 +1212,7 @@
 	return &ast.BadExpr{From: pos, To: p.pos}
 }
 
-func (p *parser) parseSelector(x ast.Expr) ast.Expr {
+func (p *Parser) parseSelector(x ast.Expr) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "Selector"))
 	}
@@ -1180,7 +1222,7 @@
 	return &ast.SelectorExpr{X: x, Sel: sel}
 }
 
-func (p *parser) parseTypeAssertion(x ast.Expr) ast.Expr {
+func (p *Parser) parseTypeAssertion(x ast.Expr) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "TypeAssertion"))
 	}
@@ -1198,7 +1240,7 @@
 	return &ast.TypeAssertExpr{X: x, Type: typ, Lparen: lparen, Rparen: rparen}
 }
 
-func (p *parser) parseIndexOrSlice(x ast.Expr) ast.Expr {
+func (p *Parser) parseIndexOrSlice(x ast.Expr) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "IndexOrSlice"))
 	}
@@ -1245,7 +1287,7 @@
 	return &ast.IndexExpr{X: x, Lbrack: lbrack, Index: index[0], Rbrack: rbrack}
 }
 
-func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {
+func (p *Parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {
 	if p.trace {
 		defer un(trace(p, "CallOrConversion"))
 	}
@@ -1271,7 +1313,7 @@
 	return &ast.CallExpr{Fun: fun, Lparen: lparen, Args: list, Ellipsis: ellipsis, Rparen: rparen}
 }
 
-func (p *parser) parseValue(keyOk bool) ast.Expr {
+func (p *Parser) parseValue(keyOk bool) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "Element"))
 	}
@@ -1313,7 +1355,7 @@
 	return x
 }
 
-func (p *parser) parseElement() ast.Expr {
+func (p *Parser) parseElement() ast.Expr {
 	if p.trace {
 		defer un(trace(p, "Element"))
 	}
@@ -1328,7 +1370,7 @@
 	return x
 }
 
-func (p *parser) parseElementList() (list []ast.Expr) {
+func (p *Parser) parseElementList() (list []ast.Expr) {
 	if p.trace {
 		defer un(trace(p, "ElementList"))
 	}
@@ -1344,7 +1386,7 @@
 	return
 }
 
-func (p *parser) parseLiteralValue(typ ast.Expr) ast.Expr {
+func (p *Parser) parseLiteralValue(typ ast.Expr) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "LiteralValue"))
 	}
@@ -1361,7 +1403,7 @@
 }
 
 // checkExpr checks that x is an expression (and not a type).
-func (p *parser) checkExpr(x ast.Expr) ast.Expr {
+func (p *Parser) checkExpr(x ast.Expr) ast.Expr {
 	switch unparen(x).(type) {
 	case *ast.BadExpr:
 	case *ast.Ident:
@@ -1441,7 +1483,7 @@
 // checkExprOrType checks that x is an expression or a type
 // (and not a raw type such as [...]T).
 //
-func (p *parser) checkExprOrType(x ast.Expr) ast.Expr {
+func (p *Parser) checkExprOrType(x ast.Expr) ast.Expr {
 	switch t := unparen(x).(type) {
 	case *ast.ParenExpr:
 		panic("unreachable")
@@ -1458,7 +1500,7 @@
 }
 
 // If lhs is set and the result is an identifier, it is not resolved.
-func (p *parser) parsePrimaryExpr(lhs bool) ast.Expr {
+func (p *Parser) parsePrimaryExpr(lhs bool) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "PrimaryExpr"))
 	}
@@ -1513,7 +1555,7 @@
 }
 
 // If lhs is set and the result is an identifier, it is not resolved.
-func (p *parser) parseUnaryExpr(lhs bool) ast.Expr {
+func (p *Parser) parseUnaryExpr(lhs bool) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "UnaryExpr"))
 	}
@@ -1582,7 +1624,7 @@
 	return p.parsePrimaryExpr(lhs)
 }
 
-func (p *parser) tokPrec() (token.Token, int) {
+func (p *Parser) tokPrec() (token.Token, int) {
 	tok := p.tok
 	if p.inRhs && tok == token.ASSIGN {
 		tok = token.EQL
@@ -1591,7 +1633,7 @@
 }
 
 // If lhs is set and the result is an identifier, it is not resolved.
-func (p *parser) parseBinaryExpr(lhs bool, prec1 int) ast.Expr {
+func (p *Parser) parseBinaryExpr(lhs bool, prec1 int) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "BinaryExpr"))
 	}
@@ -1616,7 +1658,7 @@
 // The result may be a type or even a raw type ([...]int). Callers must
 // check the result (using checkExpr or checkExprOrType), depending on
 // context.
-func (p *parser) parseExpr(lhs bool) ast.Expr {
+func (p *Parser) parseExpr(lhs bool) ast.Expr {
 	if p.trace {
 		defer un(trace(p, "Expression"))
 	}
@@ -1624,7 +1666,7 @@
 	return p.parseBinaryExpr(lhs, token.LowestPrec+1)
 }
 
-func (p *parser) parseRhs() ast.Expr {
+func (p *Parser) parseRhs() ast.Expr {
 	old := p.inRhs
 	p.inRhs = true
 	x := p.checkExpr(p.parseExpr(false))
@@ -1632,7 +1674,7 @@
 	return x
 }
 
-func (p *parser) parseRhsOrType() ast.Expr {
+func (p *Parser) parseRhsOrType() ast.Expr {
 	old := p.inRhs
 	p.inRhs = true
 	x := p.checkExprOrType(p.parseExpr(false))
@@ -1654,7 +1696,7 @@
 // of a range clause (with mode == rangeOk). The returned statement is an
 // assignment with a right-hand side that is a single unary expression of
 // the form "range x". No guarantees are given for the left-hand side.
-func (p *parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {
+func (p *Parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {
 	if p.trace {
 		defer un(trace(p, "SimpleStmt"))
 	}
@@ -1732,7 +1774,7 @@
 	return &ast.ExprStmt{X: x[0]}, false
 }
 
-func (p *parser) parseCallExpr(callType string) *ast.CallExpr {
+func (p *Parser) parseCallExpr(callType string) *ast.CallExpr {
 	x := p.parseRhsOrType() // could be a conversion: (some type)(x)
 	if call, isCall := x.(*ast.CallExpr); isCall {
 		return call
@@ -1744,7 +1786,7 @@
 	return nil
 }
 
-func (p *parser) parseGoStmt() ast.Stmt {
+func (p *Parser) parseGoStmt() ast.Stmt {
 	if p.trace {
 		defer un(trace(p, "GoStmt"))
 	}
@@ -1759,7 +1801,7 @@
 	return &ast.GoStmt{Go: pos, Call: call}
 }
 
-func (p *parser) parseDeferStmt() ast.Stmt {
+func (p *Parser) parseDeferStmt() ast.Stmt {
 	if p.trace {
 		defer un(trace(p, "DeferStmt"))
 	}
@@ -1774,7 +1816,7 @@
 	return &ast.DeferStmt{Defer: pos, Call: call}
 }
 
-func (p *parser) parseReturnStmt() *ast.ReturnStmt {
+func (p *Parser) parseReturnStmt() *ast.ReturnStmt {
 	if p.trace {
 		defer un(trace(p, "ReturnStmt"))
 	}
@@ -1790,7 +1832,7 @@
 	return &ast.ReturnStmt{Return: pos, Results: x}
 }
 
-func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
+func (p *Parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
 	if p.trace {
 		defer un(trace(p, "BranchStmt"))
 	}
@@ -1808,7 +1850,7 @@
 	return &ast.BranchStmt{TokPos: pos, Tok: tok, Label: label}
 }
 
-func (p *parser) makeExpr(s ast.Stmt, kind string) ast.Expr {
+func (p *Parser) makeExpr(s ast.Stmt, kind string) ast.Expr {
 	if s == nil {
 		return nil
 	}
@@ -1819,7 +1861,7 @@
 	return &ast.BadExpr{From: s.Pos(), To: p.safePos(s.End())}
 }
 
-func (p *parser) parseIfStmt() *ast.IfStmt {
+func (p *Parser) parseIfStmt() *ast.IfStmt {
 	if p.trace {
 		defer un(trace(p, "IfStmt"))
 	}
@@ -1870,7 +1912,7 @@
 	return &ast.IfStmt{If: pos, Init: s, Cond: x, Body: body, Else: else_}
 }
 
-func (p *parser) parseTypeList() (list []ast.Expr) {
+func (p *Parser) parseTypeList() (list []ast.Expr) {
 	if p.trace {
 		defer un(trace(p, "TypeList"))
 	}
@@ -1884,7 +1926,7 @@
 	return
 }
 
-func (p *parser) parseCaseClause(typeSwitch bool) *ast.CaseClause {
+func (p *Parser) parseCaseClause(typeSwitch bool) *ast.CaseClause {
 	if p.trace {
 		defer un(trace(p, "CaseClause"))
 	}
@@ -1915,7 +1957,7 @@
 	return ok && a.Type == nil
 }
 
-func (p *parser) isTypeSwitchGuard(s ast.Stmt) bool {
+func (p *Parser) isTypeSwitchGuard(s ast.Stmt) bool {
 	switch t := s.(type) {
 	case *ast.ExprStmt:
 		// x.(type)
@@ -1936,7 +1978,7 @@
 	return false
 }
 
-func (p *parser) parseSwitchStmt() ast.Stmt {
+func (p *Parser) parseSwitchStmt() ast.Stmt {
 	if p.trace {
 		defer un(trace(p, "SwitchStmt"))
 	}
@@ -1994,7 +2036,7 @@
 	return &ast.SwitchStmt{Switch: pos, Init: s1, Tag: p.makeExpr(s2, "switch expression"), Body: body}
 }
 
-func (p *parser) parseCommClause() *ast.CommClause {
+func (p *Parser) parseCommClause() *ast.CommClause {
 	if p.trace {
 		defer un(trace(p, "CommClause"))
 	}
@@ -2052,7 +2094,7 @@
 	return &ast.CommClause{Case: pos, Comm: comm, Colon: colon, Body: body}
 }
 
-func (p *parser) parseSelectStmt() *ast.SelectStmt {
+func (p *Parser) parseSelectStmt() *ast.SelectStmt {
 	if p.trace {
 		defer un(trace(p, "SelectStmt"))
 	}
@@ -2070,7 +2112,7 @@
 	return &ast.SelectStmt{Select: pos, Body: body}
 }
 
-func (p *parser) parseForStmt() ast.Stmt {
+func (p *Parser) parseForStmt() ast.Stmt {
 	if p.trace {
 		defer un(trace(p, "ForStmt"))
 	}
@@ -2153,7 +2195,7 @@
 	}
 }
 
-func (p *parser) parseStmt() (s ast.Stmt) {
+func (p *Parser) parseStmt() (s ast.Stmt) {
 	if p.trace {
 		defer un(trace(p, "Statement"))
 	}
@@ -2165,7 +2207,16 @@
 		// tokens that may start an expression
 		token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operands
 		token.LBRACK, token.STRUCT, token.MAP, token.CHAN, token.INTERFACE, // composite types
-		token.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT: // unary operators
+		token.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT, // unary operators
+		// patch: macro, quote and friends
+		mt.INTERPRET_ONLY, mt.MACRO, mt.SPLICE, mt.QUOTE, mt.QUASIQUOTE, mt.UNQUOTE, mt.UNQUOTE_SPLICE:
+
+		if p.tok == token.IDENT {
+			s = p.tryParseMacroStmt()
+			if s != nil {
+				break
+			}
+		}
 		s, _ = p.parseSimpleStmt(labelOk)
 		// because of the required look-ahead, labeled statements are
 		// parsed by parseSimpleStmt - don't expect a semicolon after
@@ -2228,7 +2279,7 @@
 	return s != ""
 }
 
-func (p *parser) parseImportSpec(doc *ast.CommentGroup, _ token.Token, _ int) ast.Spec {
+func (p *Parser) parseImportSpec(doc *ast.CommentGroup, _ token.Token, _ int) ast.Spec {
 	if p.trace {
 		defer un(trace(p, "ImportSpec"))
 	}
@@ -2267,7 +2318,7 @@
 	return spec
 }
 
-func (p *parser) parseValueSpec(doc *ast.CommentGroup, keyword token.Token, iota int) ast.Spec {
+func (p *Parser) parseValueSpec(doc *ast.CommentGroup, keyword token.Token, iota int) ast.Spec {
 	if p.trace {
 		defer un(trace(p, keyword.String()+"Spec"))
 	}
@@ -2314,7 +2365,7 @@
 	return spec
 }
 
-func (p *parser) parseTypeSpec(doc *ast.CommentGroup, _ token.Token, _ int) ast.Spec {
+func (p *Parser) parseTypeSpec(doc *ast.CommentGroup, _ token.Token, _ int) ast.Spec {
 	if p.trace {
 		defer un(trace(p, "TypeSpec"))
 	}
@@ -2335,7 +2386,7 @@
 	return spec
 }
 
-func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.GenDecl {
+func (p *Parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.GenDecl {
 	if p.trace {
 		defer un(trace(p, "GenDecl("+keyword.String()+")"))
 	}
@@ -2366,17 +2417,43 @@
 	}
 }
 
-func (p *parser) parseFuncDecl() *ast.FuncDecl {
+func (p *Parser) parseFuncDecl() *ast.FuncDecl {
 	if p.trace {
 		defer un(trace(p, "FunctionDecl"))
 	}
+	decl := p.parseFuncOrMacroDecl(token.FUNC)
+
+	// patch: empty receiver list is omitted.
+	// used to distinguish functions from macros:
+	// for functions, receiver is nil or one-element list
+	// for macros, receiver is zero-element list
+	recv := decl.Recv
+	if recv != nil && len(recv.List) == 0 {
+		decl.Recv = nil
+	}
+	return decl
+}
+
+// patch: parse a macro declaration
+func (p *Parser) parseMacroDecl() *ast.FuncDecl {
+	if p.trace {
+		defer un(trace(p, "MacroDecl"))
+	}
+	decl := p.parseFuncOrMacroDecl(mt.MACRO)
+	// add zero-length receiver list, to mark decl as a macro
+	decl.Recv = &ast.FieldList{List: []*ast.Field{}}
+	return decl
+}
+
+func (p *Parser) parseFuncOrMacroDecl(tok token.Token) *ast.FuncDecl {
 
 	doc := p.leadComment
-	pos := p.expect(token.FUNC)
+	pos := p.expect(tok)
 	scope := ast.NewScope(p.topScope) // function scope
 
 	var recv *ast.FieldList
-	if p.tok == token.LPAREN {
+	// patch: macros cannot have a receiver
+	if tok == token.FUNC && p.tok == token.LPAREN {
 		recv = p.parseParameters(scope, false)
 	}
 
@@ -2416,7 +2493,7 @@
 	return decl
 }
 
-func (p *parser) parseDecl(sync func(*parser)) ast.Decl {
+func (p *Parser) parseDecl(sync func(*Parser)) ast.Decl {
 	if p.trace {
 		defer un(trace(p, "Declaration"))
 	}
@@ -2432,6 +2509,9 @@
 	case token.FUNC:
 		return p.parseFuncDecl()
 
+	case mt.MACRO: // patch: parse a macro declaration
+		return p.parseMacroDecl()
+
 	default:
 		pos := p.pos
 		p.errorExpected(pos, "declaration")
@@ -2445,7 +2525,7 @@
 // ----------------------------------------------------------------------------
 // Source files
 
-func (p *parser) parseFile() *ast.File {
+func (p *Parser) parseFile() *ast.File {
 	if p.trace {
 		defer un(trace(p, "File"))
 	}
