// -------------------------------------------------------------
// DO NOT EDIT! this file was generated automatically by gomacro
// Any change will be lost when the file is re-generated
// -------------------------------------------------------------

/*
 * gomacro - A Go interpreter with Lisp-like macros
 *
 * Copyright (C) 2017 Massimiliano Ghilardi
 *
 *     This program is free software you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http//www.gnu.org/licenses/>.
 *
 * call1ret1.go
 *
 *  Created on Apr 15, 2017
 *      Author Massimiliano Ghilardi
 */

package fast

import (
	r "reflect"
)

func call1ret1(c *Call, maxdepth int) I {
	expr := c.Fun
	exprfun := expr.AsX1()
	funvar := c.Funvar
	var funupn, funindex int
	if funvar != nil {
		funupn = funvar.Upn
		funindex = funvar.Desc.Index()
	}
	karg0 := expr.Type.In(0).Kind()
	kret := expr.Type.Out(0).Kind()
	arg0 := c.Args[0]
	argfun := c.Argfuns[0]
	var cachedfunv r.Value
	var call I
	switch kret {
	case r.Bool:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) bool

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) bool

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) bool

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) bool

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) bool

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) bool

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) bool

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) bool

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) bool

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) bool

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) bool

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) bool

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) bool

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) bool

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) bool

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) bool

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) bool

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) bool)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) bool {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) bool)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) bool {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) bool {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) bool {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) bool {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) bool {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) bool)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) bool {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return ret0.Bool()
			}
		}
	case r.Int:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) int

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) int

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) int

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) int

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) int

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) int

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) int

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) int

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) int

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) int

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) int

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) int

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) int

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) int

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) int

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) int

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) int

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) int {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) int {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return int(ret0.Int())
			}
		}
	case r.Int8:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) int8

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) int8

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) int8

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) int8

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) int8

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) int8

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) int8

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) int8

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) int8

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) int8

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) int8

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) int8

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) int8

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) int8

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) int8

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) int8

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) int8

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) int8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) int8 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return int8(ret0.Int())
			}
		}
	case r.Int16:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) int16

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) int16

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) int16

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) int16

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) int16

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) int16

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) int16

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) int16

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) int16

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) int16

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) int16

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) int16

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) int16

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) int16

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) int16

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) int16

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) int16

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) int16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) int16 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return int16(ret0.Int())
			}
		}
	case r.Int32:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) int32

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) int32

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) int32

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) int32

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) int32

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) int32

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) int32

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) int32

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) int32

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) int32

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) int32

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) int32

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) int32

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) int32

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) int32

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) int32

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) int32

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) int32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) int32 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return int32(ret0.Int())
			}
		}
	case r.Int64:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) int64

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) int64

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) int64

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) int64

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) int64

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) int64

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) int64

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) int64

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) int64

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) int64

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) int64

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) int64

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) int64

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) int64

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) int64

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) int64

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) int64

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) int64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) int64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) int64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) int64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) int64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) int64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) int64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) int64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) int64 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return ret0.Int()
			}
		}
	case r.Uint:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) uint

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) uint

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) uint

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) uint

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) uint

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) uint

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) uint

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) uint

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) uint

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) uint

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) uint

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) uint

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) uint

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) uint

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) uint

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) uint

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) uint

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) uint {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) uint {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return uint(ret0.Uint())
			}
		}

	case r.Uint8:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) uint8

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) uint8

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) uint8

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) uint8

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) uint8

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) uint8

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) uint8

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) uint8

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) uint8

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) uint8

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) uint8

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) uint8

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) uint8

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) uint8

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) uint8

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) uint8

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) uint8

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint8)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) uint8 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint8)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint8 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint8 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint8 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint8 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint8 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint8)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) uint8 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return uint8(ret0.Uint())
			}
		}

	case r.Uint16:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) uint16

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) uint16

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) uint16

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) uint16

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) uint16

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) uint16

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) uint16

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) uint16

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) uint16

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) uint16

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) uint16

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) uint16

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) uint16

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) uint16

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) uint16

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) uint16

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) uint16

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint16)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) uint16 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint16)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint16 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint16 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint16 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint16 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint16 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint16)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) uint16 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return uint16(ret0.Uint())
			}
		}

	case r.Uint32:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) uint32

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) uint32

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) uint32

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) uint32

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) uint32

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) uint32

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) uint32

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) uint32

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) uint32

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) uint32

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) uint32

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) uint32

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) uint32

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) uint32

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) uint32

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) uint32

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) uint32

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) uint32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) uint32 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return uint32(ret0.Uint())
			}
		}

	case r.Uint64:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) uint64

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) uint64

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) uint64

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) uint64

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) uint64

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) uint64

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) uint64

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) uint64

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) uint64

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) uint64

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) uint64

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) uint64

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) uint64

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) uint64

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) uint64

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) uint64

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) uint64

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) uint64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uint64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uint64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uint64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uint64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uint64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uint64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uint64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) uint64 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return ret0.Uint()
			}
		}

	case r.Uintptr:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) uintptr

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uintptr)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) uintptr {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) uintptr)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) uintptr {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) uintptr {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) uintptr {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) uintptr {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) uintptr {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) uintptr)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) uintptr {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return uintptr(ret0.Uint())
			}
		}

	case r.Float32:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) float32

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) float32

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) float32

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) float32

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) float32

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) float32

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) float32

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) float32

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) float32

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) float32

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) float32

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) float32

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) float32

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) float32

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) float32

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) float32

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) float32

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) float32)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) float32 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) float32)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float32 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float32 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float32 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float32 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float32 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float32)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) float32 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return float32(ret0.Float())
			}
		}

	case r.Float64:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) float64

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) float64

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) float64

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) float64

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) float64

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) float64

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) float64

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) float64

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) float64

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) float64

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) float64

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) float64

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) float64

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) float64

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) float64

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) float64

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) float64

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) float64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) float64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) float64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) float64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) float64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) float64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) float64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) float64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) float64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) float64 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return ret0.Float()
			}
		}

	case r.Complex64:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) complex64

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) complex64

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) complex64

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) complex64

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) complex64

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) complex64

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) complex64

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) complex64

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) complex64

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) complex64

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) complex64

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) complex64

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) complex64

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) complex64

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) complex64

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) complex64

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) complex64

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) complex64)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) complex64 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) complex64)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex64 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex64 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex64 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex64 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex64 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex64)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) complex64 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return complex64(ret0.Complex())
			}
		}

	case r.Complex128:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) complex128

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) complex128

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) complex128

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) complex128

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) complex128

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) complex128

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) complex128

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) complex128

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) complex128

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) complex128

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) complex128

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) complex128

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) complex128

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) complex128

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) complex128

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) complex128

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) complex128

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) complex128)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) complex128 {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) complex128)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) complex128 {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) complex128 {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) complex128 {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) complex128 {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) complex128 {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) complex128)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) complex128 {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return ret0.Complex()
			}
		}

	case r.String:
		switch karg0 {
		case r.Bool:

			{
				var cachedfun func(bool) string

				if arg0.Const() {
					argconst := arg0.Value.(bool)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) bool)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(bool) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(bool) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int:

			{
				var cachedfun func(int) string

				if arg0.Const() {
					argconst := arg0.Value.(int)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int8:

			{
				var cachedfun func(int8) string

				if arg0.Const() {
					argconst := arg0.Value.(int8)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int8)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int8) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int16:

			{
				var cachedfun func(int16) string

				if arg0.Const() {
					argconst := arg0.Value.(int16)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int16)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int16) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int32:

			{
				var cachedfun func(int32) string

				if arg0.Const() {
					argconst := arg0.Value.(int32)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int32)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int32) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Int64:

			{
				var cachedfun func(int64) string

				if arg0.Const() {
					argconst := arg0.Value.(int64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) int64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(int64) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(int64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint:

			{
				var cachedfun func(uint) string

				if arg0.Const() {
					argconst := arg0.Value.(uint)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint8:

			{
				var cachedfun func(uint8) string

				if arg0.Const() {
					argconst := arg0.Value.(uint8)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint8)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint8) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint8) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint16:

			{
				var cachedfun func(uint16) string

				if arg0.Const() {
					argconst := arg0.Value.(uint16)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint16)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint16) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint16) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint32:

			{
				var cachedfun func(uint32) string

				if arg0.Const() {
					argconst := arg0.Value.(uint32)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint32)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint32) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uint64:

			{
				var cachedfun func(uint64) string

				if arg0.Const() {
					argconst := arg0.Value.(uint64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uint64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uint64) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uint64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Uintptr:

			{
				var cachedfun func(uintptr) string

				if arg0.Const() {
					argconst := arg0.Value.(uintptr)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) uintptr)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(uintptr) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(uintptr) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float32:

			{
				var cachedfun func(float32) string

				if arg0.Const() {
					argconst := arg0.Value.(float32)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float32)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float32) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float32) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Float64:

			{
				var cachedfun func(float64) string

				if arg0.Const() {
					argconst := arg0.Value.(float64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) float64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(float64) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(float64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex64:

			{
				var cachedfun func(complex64) string

				if arg0.Const() {
					argconst := arg0.Value.(complex64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex64)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex64) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex64) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.Complex128:

			{
				var cachedfun func(complex128) string

				if arg0.Const() {
					argconst := arg0.Value.(complex128)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) complex128)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(complex128) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(complex128) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		case r.String:

			{
				var cachedfun func(string) string

				if arg0.Const() {
					argconst := arg0.Value.(string)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) string)
							}
							return cachedfun(argconst)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}
								return cachedfun(argconst)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}
								return cachedfun(argconst)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}
								return cachedfun(argconst)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}
								return cachedfun(argconst)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}
								return cachedfun(argconst)
							}
						}
					}

				} else {
					argfun := arg0.Fun.(func(env *Env) string)
					if funvar == nil {
						call = func(env *Env) string {
							funv := exprfun(env)
							if cachedfunv != funv {
								cachedfunv = funv
								cachedfun = funv.Interface().(func(string) string)
							}

							arg := argfun(env)
							return cachedfun(arg)
						}
					} else {
						switch funupn {
						case 0:
							call = func(env *Env) string {
								funv := env.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 1:
							call = func(env *Env) string {
								funv := env.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case 2:
							call = func(env *Env) string {
								funv := env.Outer.Outer.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						default:
							call = func(env *Env) string {
								o := env
								for i := 0; i < funupn; i++ {
									o = o.Outer
								}

								funv := o.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth - 1:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.FileEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						case maxdepth:
							call = func(env *Env) string {
								funv := env.ThreadGlobals.TopEnv.Binds[funindex]
								if cachedfunv != funv {
									cachedfunv = funv
									cachedfun = funv.Interface().(func(string) string)
								}

								arg := argfun(env)
								return cachedfun(arg)
							}
						}
					}

				}
			}
		default:
			call = func(env *Env) string {
				funv := exprfun(env)
				argv := []r.Value{
					argfun(env),
				}

				ret0 := funv.Call(argv)[0]
				return ret0.String()
			}
		}

	default:
		call = func(env *Env) r.Value {
			funv := exprfun(env)
			argv := []r.Value{
				argfun(env),
			}
			return funv.Call(argv)[0]
		}

	}
	return call
}
